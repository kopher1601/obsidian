커버링 인덱스를 사용하여 데이터를 직접 읽지 않고도 집계 결과를 알 수 있는 이유는 **인덱스 자체가 집계에 필요한 모든 정보를 담고 있기 때문입니다.**

## 🔍 커버링 인덱스의 원리

### 1. 인덱스의 구조와 역할
데이터베이스의 **인덱스(Index)** 는 테이블의 특정 컬럼 값을 저장하고, 그 값이 테이블의 어느 행에 있는지 포인터(주소)를 함께 저장하는 구조입니다.

- **일반적인 인덱스 조회 과정:**
    1. 인덱스에서 조건에 맞는 데이터를 찾습니다.
    2. 인덱스에 저장된 포인터(주소)를 이용하여 **테이블의 실제 데이터 페이지**로 이동합니다. (이를 **랜덤 I/O** 또는 $\text{Table Access}$라고 합니다.)
    3. 실제 데이터를 읽습니다.

### 2. 커버링 인덱스 (Covering Index)
**커버링 인덱스**란, **쿼리에서 필요로 하는 모든 컬럼을 인덱스 자체에 모두 포함하고 있는 인덱스**를 말합니다.
예를 들어, `SELECT COUNT(column_A), SUM(column_B) FROM table WHERE column_C = 'value'`라는 쿼리가 있다고 가정해 봅시다.

이때 인덱스가 $text{(column_C, column_A, column_B)}$로 생성되어 있다면:
- **`column_C`는 WHERE 조건** 을 만족하는 데이터를 찾는 데 사용됩니다.
- **`column_A`와 `column_B`는 집계(COUNT, SUM)** 에 필요한 컬럼입니다.
    
커버링 인덱스를 사용하면 데이터베이스는 다음과 같이 작동합니다.
1. **인덱스 스캔:** 인덱스 $text{(column_C, column_A, column_B)}$를 처음부터 끝까지 스캔하면서 `column_C` 조건에 맞는 엔트리들을 찾습니다.
2. **데이터 추출 및 집계:** 찾은 인덱스 엔트리에서 $\text{COUNT}$를 위한 $text{column_A}$ 값과 $\text{SUM}$을 위한 $text{column_B}$ 값을 **즉시 추출**하여 집계를 수행합니다.
3. **테이블 접근 생략:** 인덱스 자체에 필요한 모든 $text{column_A, column_B}$ 값이 있으므로, **테이블의 실제 레코드($\text{Data Page}$)를 읽으러 가는 과정 (Table Access)** 을 완전히 생략합니다.

### 3. 성능 향상 이유
**테이블 접근 생략**이 가져오는 이점은 다음과 같습니다.
- **I/O 최소화 (속도 향상):** 인덱스는 일반적으로 테이블 데이터보다 크기가 작고, 정렬되어 있어 **순차적으로 읽기 (Sequential I/O)** 가 가능합니다. 반면, 테이블 데이터를 읽으러 가는 $\text{Table Access}$는 느린 **랜덤 I/O**를 유발하는데, 커버링 인덱스는 이 랜덤 I/O를 완전히 제거합니다.
- **메모리 사용 감소:** 데이터를 메모리에 올릴 때, 큰 테이블 데이터($\text{Data Page}$) 대신 작은 인덱스($\text{Index Page}$)만 메모리($\text{Buffer Pool}$)에 로드하고 스캔하기 때문에 $\text{DB}$가 사용하는 메모리 리소스가 절약됩니다.
결국 커버링 인덱스는 **데이터가 존재하는지 여부를 아는 것**을 넘어, **데이터 자체를 인덱스 페이지에 저장**하고 있기 때문에 데이터를 직접 읽지 않고도 필요한 모든 정보를 얻어 집계를 수행할 수 있는 것입니다.