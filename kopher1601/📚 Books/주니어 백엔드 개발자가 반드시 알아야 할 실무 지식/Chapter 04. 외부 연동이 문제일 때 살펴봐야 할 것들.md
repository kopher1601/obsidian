## 우리는 문제가 없는데
연동하는 서비스에 장애가 발생하면 우리 서비스도 영향을 받는다. 서비스 간 연동이 많이 질수록 연동 시스템의 품질도 함께 신경써야 한다. 이를 소흘히 하면 전체 서비스가 멈추는 장애로 이어질 수 있다.

## 타임 아웃
외부 연동에서 가장 중요한 설정 중 하나는 타임아웃이다. 타임아웃은 바로 이 응답시간과 깊이 관련되어 있다. 연동 서비스를 호출할 때 타임아웃을 적절히 설정하지 않으면, 연동 서비스에 장애가 발생했을 때 전체 서비스의 품질이 급격히 나빠질 수 있다.
![[Screenshot 2025-10-28 at 18.22.52.png]]
연동 서비스에 대한 타임아웃을 설정하지 않으면, 연동 서비스의 응답이 느릴 때 처리량이 급격히 떨어진다.

### 2 가지 타임아웃: 연결 타임아웃, 읽기 타임아웃
네트워크 상황이나 연결할 서버의 상태에 따라 연결에 오랜 시간이 걸릴 수 있다. 연결에 시간이 오래 걸리면 대기 시간도 함께 증가한다. 대기 시간이 무한정 길어지면 성능 문제가 발생하므로, 연결 타임아웃(connection timeout)을 설정해 연결 대기 시간을 제한해야 한다.

일단 연결이 되면 요청을 전송하고 응답을 기다리게 된다. 이때 응답을 받기까지 시간이 오래걸리면 앞서 말한 대기 시간 문제가 다시 발생한다. 따라서 읽기 타임아웃(read timeout)을 설정해서 응답 대기 시간을 제한해야 한다.

처음 연동하는 서비스라면 타임아웃 시간을 아래와 같이 설정한 뒤, 추이를 보면서 조정하는 것이 좋다.
- 연결 타임아웃 : 3 ~ 5초
- 읽기 타임아웃 : 5 ~ 30초
읽기 타임아웃이 다소 길게 느껴질 수 있다. 하지만 처음부터 1~3초 정도로 짧게 설정하면 타임아웃 에러가 자주 발생할 수 있다. 게다가 타임아웃 시간이 너무 짧으면 연동 서비스가 정상 처리했음에도 불구하고 타임아웃 에러가 발생할 수 있다.
![[Screenshot 2025-10-28 at 18.28.28.png]]

## 재시도
외부 연동에 실패했을 때 처리 방법 중 하나는 재시도를 하는 것이다. 네트워크 통신 과정에서 간혈적으로 연결에 실패하거나 일시적으로 응답이 느려지는 경우가 있다. 이럴 때는 재시도를 통해 연동 실패를 성공으로 바꿀 수 있다.
![[Screenshot 2025-10-28 at 18.30.56.png]]
### 재시도 가능 조건
재시도를 통해 연동 실패를 줄일 수 있지만, 항상 재시도를 할 수 있는 것은 아니다. 연동 API를 다시 호출해도 되는 조건인지 확인해야 한다.

재시도를 해도 되는 조건은 다음 3가지로 정리할 수 있다.
- 단순 조회 기능
- 연결 타임아웃
- **멱등성(idempotent)** 을 가진 변경 기능
**단순 조회 기능**은 재시도를 통해 성공 확률을 높일 수 있다. 포인트 내역 조회 같은 기능은 다시 호출해도 포인트 중복 차감 같은 데이터 문제가 생기지 않는다.

**읽기 타임아웃**은 재시도할 때 주의해야 한다. 이 경우는 이미 연동 서비스가 요청을 처리하고 있는 중이기 때문이다. 읽기 타임아웃이 발생한 상황에서 재시도를 하면 포인트가 중복 차감되는 데이터 문제가 생길 수 있다.

**상태를 변경**하는 연동 API를 재시도할 때는 멱등성을 고려해야 한다. [[멱등성]]이란 연산을 여러번 적용해도 결과가 달라지지 않는 성질을 말한다.

### 재시도 횟수와 간격
재시도할 때는 다음 2가지를 결정해야 한다.
- 재시도 횟수
- 재시도 간격
재시도를 무한정 할 수는 없다. 재시도 횟수만큼 응답 시간도 함께 증가하기 때문이다. 대부분의 경우 1~2번 정도의 재시도가 적당하다. 2번 재시도를 하면 총 3번 시도한 것이 되는데, 모두 실패했다면 간헐적인 오류보다는 근본적인 문제일 가능성이 높다.

재시도 간격도 중요하다. 여러 차례 재시도할 때는 재시도 간격을 점진적으로 늘리기도 한다.

### 재시도 폭풍(retry storm) 안티패턴
재시도를 통해 성공 가능성을 높일 수 있지만, 반대로 연동 서비스에는 더 큰 부하를 줄 수있다. 엎친 데 덮친 격으로, 성능이 느려진 상태에서 새로운 요청까지 더해지면 연동 서비스의 성능은 더 나빠진다. 따라서 재시도를 검토할 때는 연동 서비스의 성능 상황도 함께 고려해야 한다.

## 동시 요청 제한
![[Screenshot 2025-10-29 at 10.58.20.png]]
연동 서비스에 임계치 이상의 요청을 보내면서 발생하는 성능 저하 문제를 완하하는 방법은, 연동 서비스에 요청을 일정 수준 이상으로 보내지 않는 것이다.
![[Screenshot 2025-10-29 at 10.58.45.png]]

> **벌크헤드(Bulkhead)**
> 동시 요청을 제한하는 방식은 벌크헤드 패턴을 활용한 것이다. 벌크헤드 패턴은 각 구성 요소를 격리함으로써 한 구성 요서의 장애가 다른 구성 요소에 영향을 주지 않도록 하는 설계 패턴이다.

## 서킷 브레이커(Circuit Breaker)
![[Screenshot 2025-10-29 at 11.01.49.png]]
B 서비스가 정상 상태가 아닐 때, A 서비스는 B 서비스에 요청을 보내지 않고 바로 에러를 응답하는 것이 낫다. 이렇게 하면 B 서비스의 문제가 A 서비스에 주는 영향(응답 시간 증가, 처리량 감소 등)을 줄일 수 있다.

또한 사용자 입장에서도 수 초를 대기하다가 에러 화면을 보는 것보다는, 빠르게 에러 화면을 보는 편이 낫다.

연동 서비스가 장애 상황일 때는 연동 대신 바로 에러를 응답하고, 정상화되었을 때 연동을 재개하면 연동 서비스의 장애가 주는 영향을 줄일 수 있다. 서킷 브레이커가 동작하는 방식이 바로 이와 같다.

서킷 브레이커는 누전 차단기와 비슷하게 동작한다. 과전류가 흐르면 차단기가 내려가 전기를 끊는 것처럼, 서킷 브레이커도 과도한 오류가 발생하면 연동을 중지시키고 바로 에러를 응답한다. 이렇게 하면 연동 서비스로의 요청 전달을 차단할 수 있다.

서킷 브레이커는 **닫힘**(closed), **열림**(open), **반 열림**(half-open) 의 3가지 상태를 갖는다.
![[Screenshot 2025-10-29 at 11.05.12.png]]

## 외부 연동과 DB 연동
### 외부 연동과 트랜잭션 처리
#### 외부 연동에 실패했을 때 트랜잭션을 롤백
![[Screenshot 2025-10-29 at 11.09.06.png]]
외부 연동에 실패했을 때 트랜잭션을 롤백하면, 변경한 데이터가 DB에 반영되지 않는다. 단순한 방식이지만, 롤백을 통해 DB 데이터에 이상이 생기는 것을 방지할 수 있다.
#### 외부 연동은 성공했는데 DB 연동에 실패해서 트랜잭션을 롤백
![[Screenshot 2025-10-29 at 11.12.07.png]]
취소 API 가 없거나 취소에 실패할 수도 있기 때문에 데이터 일관성이 중요한 서비스라면 일정 주기로 데이터가 맞는지 비교하는 프로세스를 갖추는 것이 좋다.

### 외부 연동이 느려질 때 DB 커넥션 풀 문제
DB 트랜잭션 범위 안에서 외부 연동을 수행할 때 외부 연동이 느려지면 커넥션 풀 부족 현상이 발생할 수도 있다.
- DB 연동 : 0.2초
- 외부 연동 : 4.8초

## HTTP 커넥션 풀
DB 커넥션 풀이 DB 연결에 걸리는 시간을 줄여 성능을 높이는 것처럼 HTTP 연결도 커넥션 풀을 사용하면 연결 시간을 줄일 수 있어 응답 속도 향상에 도움이 된다.

HTTP 커넥션 풀을 사용할 때는 다음 3가지를 고려해야 한다.
- HTTP 커넥션 풀의 크기
- 풀에서 HTTP 커넥션을 가져올 때까지 대기하는 시간
- HTTP 커넥션을 유지할 시간(keep alive)

**풀의 크기**
HTTP 커넥션 풀을 사용할 때 가장 먼저 고려해야 할 값은 **풀의 크기**다. 풀의 크기는 연동할 서비스의 성능에 따라 결정해야 한다. 연동 서비스의 성능을 고려하지 않고 무턱대고 커넥션 풀 크기를 늘리면 순간적으로 트래픽이 몰릴 때 연동 서비스의 응답 시간이 급격히 느려질 수 있다.

**대기 시간**
HTTP 커넥션 풀의 대기시간은 1~5초 사이가 적당

**커넥션 유지 시간**
`HTTP/1.1` 에서는 서버가 `Keep-Alive` 헤더로 연결 유지 시간을 지정한다. 이 시간이 지나면 서버는 연결을 끊기 때문에, 클라이언트의 커넥션 풀도 이 값보다 더 오래 커넥션을 유지하면 안 된다.

## 연동 서비스 이중화
서비스가 대량 트래픽을 처리할 만큼 성장했다면 연동 서비스의 이중화를 고려해야 한다.
